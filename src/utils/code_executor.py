"""Safe code execution utilities using Jupyter kernels."""

import json
import queue
import tempfile
from pathlib import Path
from typing import Any, Optional

from jupyter_client import KernelManager
import nbformat

from .logging_utils import get_logger

logger = get_logger(__name__)


class CodeExecutor:
    """Execute code safely in an isolated Jupyter kernel.

    This class provides a sandbox environment for executing Python code
    generated by the replicator agent.
    """

    def __init__(
        self,
        timeout: int = 300,
        kernel_name: str = "python3",
        working_dir: Optional[str] = None,
    ):
        """Initialize the code executor.

        Args:
            timeout: Maximum execution time in seconds.
            kernel_name: Jupyter kernel to use.
            working_dir: Working directory for code execution.
        """
        self.timeout = timeout
        self.kernel_name = kernel_name
        self.working_dir = working_dir or tempfile.mkdtemp()
        self.km: Optional[KernelManager] = None
        self.kc = None
        self._started = False

    def start(self) -> None:
        """Start the Jupyter kernel."""
        if self._started:
            return

        logger.info(f"Starting Jupyter kernel: {self.kernel_name}")

        self.km = KernelManager(kernel_name=self.kernel_name)
        self.km.start_kernel(cwd=self.working_dir)
        self.kc = self.km.client()
        self.kc.start_channels()
        self.kc.wait_for_ready(timeout=30)
        self._started = True

        logger.info("Kernel started successfully")

    def stop(self) -> None:
        """Stop the Jupyter kernel."""
        if not self._started:
            return

        logger.info("Stopping Jupyter kernel")

        if self.kc:
            self.kc.stop_channels()
        if self.km:
            self.km.shutdown_kernel(now=True)

        self._started = False
        self.km = None
        self.kc = None

    def __enter__(self):
        """Context manager entry."""
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.stop()

    def execute(self, code: str) -> dict[str, Any]:
        """Execute code and return results.

        Args:
            code: Python code to execute.

        Returns:
            Dictionary containing:
            - 'success': Whether execution succeeded
            - 'output': Standard output
            - 'error': Error message if any
            - 'data': Any rich output data (images, HTML, etc.)
        """
        if not self._started:
            self.start()

        logger.debug(f"Executing code:\n{code[:200]}...")

        result = {
            "success": True,
            "output": "",
            "error": None,
            "data": [],
        }

        try:
            msg_id = self.kc.execute(code)

            outputs = []
            while True:
                try:
                    msg = self.kc.get_iopub_msg(timeout=self.timeout)
                except queue.Empty:
                    result["success"] = False
                    result["error"] = f"Execution timed out after {self.timeout} seconds"
                    break

                msg_type = msg["msg_type"]
                content = msg["content"]

                if msg_type == "status" and content.get("execution_state") == "idle":
                    break

                elif msg_type == "stream":
                    outputs.append(content["text"])

                elif msg_type == "execute_result":
                    if "text/plain" in content.get("data", {}):
                        outputs.append(content["data"]["text/plain"])
                    result["data"].append(content.get("data", {}))

                elif msg_type == "display_data":
                    result["data"].append(content.get("data", {}))

                elif msg_type == "error":
                    result["success"] = False
                    error_msg = "\n".join(content.get("traceback", []))
                    result["error"] = error_msg
                    break

            result["output"] = "".join(outputs)

        except Exception as e:
            result["success"] = False
            result["error"] = str(e)
            logger.error(f"Execution error: {e}")

        return result

    def execute_file(self, file_path: str) -> dict[str, Any]:
        """Execute a Python file.

        Args:
            file_path: Path to the Python file.

        Returns:
            Execution results (same format as execute()).
        """
        path = Path(file_path)
        if not path.exists():
            return {
                "success": False,
                "output": "",
                "error": f"File not found: {file_path}",
                "data": [],
            }

        code = path.read_text()
        return self.execute(code)

    def set_variable(self, name: str, value: Any) -> None:
        """Set a variable in the kernel namespace.

        Args:
            name: Variable name.
            value: Variable value (must be JSON serializable for complex types).
        """
        if isinstance(value, (str, int, float, bool, type(None))):
            code = f"{name} = {repr(value)}"
        else:
            # For complex types, serialize via JSON
            json_str = json.dumps(value)
            code = f"import json\n{name} = json.loads({repr(json_str)})"

        self.execute(code)

    def get_variable(self, name: str) -> Any:
        """Get a variable from the kernel namespace.

        Args:
            name: Variable name.

        Returns:
            Variable value, or None if not found.
        """
        result = self.execute(f"import json\nprint(json.dumps({name}))")
        if result["success"] and result["output"]:
            try:
                return json.loads(result["output"].strip())
            except json.JSONDecodeError:
                pass
        return None

    def install_package(self, package: str) -> bool:
        """Install a Python package in the kernel environment.

        Args:
            package: Package name (e.g., 'pandas', 'numpy>=1.0').

        Returns:
            Whether installation succeeded.
        """
        result = self.execute(f"!pip install -q {package}")
        return result["success"]


def create_notebook_from_code(
    code_blocks: list[str],
    output_path: str,
    descriptions: Optional[list[str]] = None,
) -> str:
    """Create a Jupyter notebook from code blocks.

    Args:
        code_blocks: List of code strings.
        output_path: Path to save the notebook.
        descriptions: Optional descriptions for each code block.

    Returns:
        Path to the created notebook.
    """
    nb = nbformat.v4.new_notebook()
    cells = []

    for i, code in enumerate(code_blocks):
        # Add markdown cell with description if provided
        if descriptions and i < len(descriptions):
            md_cell = nbformat.v4.new_markdown_cell(descriptions[i])
            cells.append(md_cell)

        # Add code cell
        code_cell = nbformat.v4.new_code_cell(code)
        cells.append(code_cell)

    nb.cells = cells

    path = Path(output_path)
    path.parent.mkdir(parents=True, exist_ok=True)

    with open(path, "w") as f:
        nbformat.write(nb, f)

    logger.info(f"Created notebook: {output_path}")
    return str(path)
